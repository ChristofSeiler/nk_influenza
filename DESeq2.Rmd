---
title: "DESeq2 Workflow"
output: html_document
author: Christof Seiler
date: October, 2016
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

Establish DESeq2 workflow starting from BAM files generated by tophat2. 
To get the BAM files first install all necessary software and submit aligment script to sherlock. 

1. Run ``bash Installation.bash`` in your ``$HOME`` folder 
2. Run ``tophat2`` aligment using ``bash Alignment.bash`` in your ``$SCRATCH`` folder

This is based on [DESeq2 vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.pdf) and entire [DESeq2 workflow documentation](http://www.bioconductor.org/help/workflows/rnaseqGene/).

## Workfow

Load packages.

```{r message=FALSE}
#source("https://bioconductor.org/biocLite.R")
#biocLite("Rsamtools")
#biocLite("GenomicFeatures")
library(DESeq2)
library(Rsamtools)
library(GenomicFeatures)
library(GenomicAlignments)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(BiocParallel)
n_cores = as.integer(Sys.getenv("SLURM_NTASKS"))
n_cores
register(MulticoreParam(workers = n_cores))
```

### Prepare Count Matrix

Import BAM file into R.

```{r}
csvfile = file.path("sample_table_UI_H3N2.csv")
sample_table = read.csv(csvfile,row.names=1)
file_names = paste0(sample_table$name,"_STAR.bam")
bamfiles = BamFileList(file_names, yieldSize=2000000)
seqinfo(bamfiles[1])
```

Define gene model (this is downloaded during ``Installation.bash`` automatically). Buidling the database takes a long time.

```{r}
# txdb_file_name = "txdb_Ensembl_75.Rdata"
# if(!file.exists(txdb_file_name)) {
#   library(AnnotationHub)
#   ah = AnnotationHub()
#   gtf = query(ah, c("GTF", "75","Ensembl", "Homo sapiens"))
#   gtf = ah[["AH10684"]]
#   txdb = makeTxDbFromGRanges(gtf)
#   #gene_model_path = Sys.getenv("ENSEMBL")
#   #gtffile = file.path(gene_model_path,"Homo_sapiens.GRCh37.75.gtf")
#   #txdb = makeTxDbFromGFF(gtffile, format="gtf", circ_seqs=character())
#   save(txdb,file = txdb_file_name)
# } else {
#   load(txdb_file_name)
# }
```

As an alternative, we can use the prefabricated database.

```{r}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb = TxDb.Hsapiens.UCSC.hg38.knownGene
txdb
```

List of all the exons grouped by gene.

```{r}
ebg = exonsBy(txdb, by="gene")
ebg
```

Read counting step.

```{r}
se = summarizeOverlaps(features=ebg, reads=bamfiles,
                       mode="Union",
                       singleEnd=FALSE,
                       ignore.strand=TRUE,
                       fragments=TRUE )
se
dim(se)
rowRanges(se)
str(metadata(rowRanges(se)))
colData(se) = DataFrame(sample_table)
colData(se)
save(se,file = "se.Rdata")
```

This completes the counting step, we have counted the fragments which overlap the genes in the gene model we specified. Now we can feed this into many different kind of linear models in Bioconductor, one option is to use the ``DESeq2`` package.

### Differential Expression Analysis

Change reference treatment to uninfected UI. Optimize the number of genes which will have an adjusted p value below a given FDR cutoff value ``alpha``.

```{r}
dds = DESeqDataSet(se, design = ~ harvest + donor + treatment)
dds$treatment = relevel(dds$treatment, ref="UI")
dds = DESeq(dds)
res = results(dds, alpha=0.1)
```

Order results table by the smallest adjusted p-value.

```{r}
res_ordered <- res[order(res$padj),]
```

Some basics stats.

```{r}
summary(res)
```

Count how many p-values were less than 0.1.

```{r}
sum(res$padj < 0.1, na.rm=TRUE)
```

Shows the log2 fold changes.

```{r}
plotMA(res, main="DESeq2", ylim=c(-2,2))
```

More infos about variables and tests.

```{r}
mcols(res)$description
```

Histogram of the p values. Exclude genes with only one count to avoid spikes.

```{r}
hist(res$pvalue[res$baseMean > 1], breaks=0:20/20, col="grey50", border="white")
```

### Data Quality Assessment

Extracting transformed values.

```{r}
rld = rlog(dds, blind=FALSE)
head(assay(rld), 3)
```

Heatmap of top 20 genes.

```{r}
select = order(rowMeans(counts(dds,normalized=TRUE)),decreasing=TRUE)[1:20]
nt = normTransform(dds) # defaults to log2(x+1)
log2.norm.counts = assay(nt)[select,]
df = as.data.frame(colData(dds)[,c("donor","harvest","treatment")])
pheatmap(log2.norm.counts, cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
```

Heatmap of the sample-to-sample distances.

```{r}
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

Principal component plot of the samples.

```{r}
data = plotPCA(rld, intgroup=c("treatment","harvest"), returnData=TRUE)
percentVar = round(100 * attr(data, "percentVar"))
ggplot(data, aes(PC1, PC2, color=treatment, shape=harvest)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  coord_fixed()
plotPCA(rld, intgroup=c("donor"))
```

### Export Results

Write to text file.

```{r}
write.csv(as.data.frame(res_ordered),
          file=paste0(paste0(levels(colData(dds)$treatment),
                             collapse = "_"),"_results.csv"))
```
